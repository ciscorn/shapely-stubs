from typing import Callable, Literal, overload

from ._typing import _ArrayLikeGeometry, _NDArrayGeometry, _NDArrayObject
from .geometry import GeometryCollection, LineString, MultiLineString, Point, Polygon
from .geometry.base import BaseGeometry, GeometrySequence

class CollectionOperator:
    def shapeup(self, ob): ...
    def polygonize(
        self, lines: MultiLineString | _ArrayLikeGeometry
    ) -> GeometrySequence: ...
    def polygonize_full(
        self, lines
    ) -> tuple[
        GeometryCollection, GeometryCollection, GeometryCollection, GeometryCollection
    ]: ...
    def linemerge(
        self, lines, directed: bool = ...
    ) -> LineString | MultiLineString: ...
    def cascaded_union(self, geoms) -> BaseGeometry: ...
    def unary_union(self, geoms) -> BaseGeometry: ...

operator: CollectionOperator
polygonize = operator.polygonize
polygonize_full = operator.polygonize_full
linemerge = operator.linemerge
cascaded_union = operator.cascaded_union
unary_union = operator.unary_union

@overload
def triangulate(
    geom: BaseGeometry, tolerance: float = ..., edges: Literal[False] = ...
) -> list[Polygon]: ...
@overload
def triangulate(
    geom: BaseGeometry, tolerance: float = ..., *, edges: Literal[True]
) -> list[LineString]: ...
@overload
def triangulate(
    geom: BaseGeometry, tolerance: float, edges: Literal[True]
) -> list[LineString]: ...
def voronoi_diagram(
    geom: BaseGeometry,
    envelope: BaseGeometry | None = ...,
    tolerance: float = ...,
    edges: bool = ...,
) -> GeometryCollection: ...
@overload
def validate(geom: BaseGeometry) -> str: ...
@overload
def validate(geom: _ArrayLikeGeometry) -> _NDArrayObject: ...
@overload
def validate(geom: None) -> None: ...
def transform(func: Callable, geom: BaseGeometry) -> BaseGeometry: ...
@overload
def nearest_points(g1: BaseGeometry, g2: BaseGeometry) -> tuple[Point, Point]: ...
@overload
def nearest_points(
    g1: _ArrayLikeGeometry, g2: BaseGeometry | _ArrayLikeGeometry | None
) -> tuple[_NDArrayGeometry, _NDArrayGeometry]: ...
@overload
def nearest_points(
    g1: BaseGeometry | _ArrayLikeGeometry | None, g2: _ArrayLikeGeometry
) -> tuple[_NDArrayGeometry, _NDArrayGeometry]: ...
@overload
def snap(g1: BaseGeometry, g2: BaseGeometry, tolerance: float) -> BaseGeometry: ...
@overload
def snap(
    g1: _ArrayLikeGeometry,
    g2: BaseGeometry | _ArrayLikeGeometry | None,
    tolerance: float,
) -> _NDArrayGeometry: ...
@overload
def snap(
    g1: BaseGeometry | _ArrayLikeGeometry | None,
    g2: _ArrayLikeGeometry,
    tolerance: float,
) -> _NDArrayGeometry: ...
@overload
def snap(g1: None, g2: BaseGeometry | None, tolerance: float) -> None: ...
@overload
def snap(g1: BaseGeometry | None, g2: None, tolerance: float) -> None: ...
def shared_paths(g1: LineString, g2: LineString) -> GeometryCollection: ...

class SplitOp:
    @staticmethod
    def split(geom: BaseGeometry, splitter: BaseGeometry): ...

split = SplitOp.split

def substring(
    geom: LineString, start_dist: float, end_dist: float, normalized: bool = ...
): ...
@overload
def clip_by_rect(
    geom: BaseGeometry, xmin: float, ymin: float, xmax: float, ymax: float
) -> BaseGeometry: ...
@overload
def clip_by_rect(
    geom: _ArrayLikeGeometry, xmin: float, ymin: float, xmax: float, ymax: float
) -> _ArrayLikeGeometry: ...
@overload
def clip_by_rect(
    geom: None, xmin: float, ymin: float, xmax: float, ymax: float
) -> None: ...
@overload
def orient(geom: BaseGeometry, sign: float = ...) -> BaseGeometry: ...
@overload
def orient(geom: _ArrayLikeGeometry, sign: float = ...) -> _NDArrayGeometry: ...
@overload
def orient(geom: None, sign: float = ...) -> None: ...
